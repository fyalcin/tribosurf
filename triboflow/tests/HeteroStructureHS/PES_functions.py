#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Wed Sep 30 18:12:33 2020

Calculate PES, MEP, shear strength

@author: gl
"""

import numpy as np
import math
from scipy.interpolate import interp1d, Rbf, interp2d, griddata


# =============================================================================
# PES EVALUATION
# =============================================================================


def GetPES(interface, pes_dict, to_fig=None):
    """
    Parameters
    ----------
    interface : TYPE
        DESCRIPTION.
    pes_dict : TYPE
        DESCRIPTION.
    to_fig : TYPE, optional
        DESCRIPTION. The default is None.

    Returns
    -------
    rbf : TYPE
        DESCRIPTION.
    pes_grid : TYPE
        DESCRIPTION.

    """
    
    lattice = interface.lattice.matrix
    
    # Calculate the PES on the provided HS points
    x, y, E = ExtractDataForPES(pes_dict)
    rbf = Rbf(x, y, E, function='cubic')
    
    # Extend the PES on a uniform fine grid to plot it
    x_new, y_new = ReplicatePESpoints(x, y, lattice, (5,5))   
    E_new = rbf(x_new, y_new)
    pes_grid = np.stack([x_new, y_new, E_new], axis=-1)
    
    return rbf, pes_grid
    

def ExtractDataForPES(pes_dict):
    """
    Extract coordinates and energies from the unfolded dictionary of the PES

    """
    x = []
    y = []
    E = []
    
    for k in pes_dict.keys():
        x.append(pes_dict[k][:, 0])
        y.append(pes_dict[k][:, 1])
        E.append(pes_dict[k][:, 2])
    
    return np.concatenate(x), np.concatenate(y), np.concatenate(E)


def ReplicatePESPoints(x, y, lattice, replicate_of = (1, 1)):
    """ 
    Replicate the of (n,m)
    
    """
    
    n = replicate_of[0]
    m = replicate_of[1]
    
    if n==0: n=1
    if m==0: m=1
    
    if n == 1 and m == 1:
        return x, y
    else:
    
        a = lattice[0, :]
        b = lattice[1, :]
        
        x_new = x.copy()
        y_new = y.copy()
        
        for i in range(1, n):
                for j in range(1, m):
                    x_add = x + a[0]*i + b[0]*j
                    y_add = y + a[1]*i + b[1]*j
                    
                    x_new = np.append([x_new, x_add])
                    y_new = np.append([y_new, y_add])
        
        return x_new, y_new


def GenerateGridForPES(alats, density, mod=0, default=5, to_plot=False):
    """
    alats must be a 2x3 matrix with the x, y, z components of a and b
    density is the number of points per unit A^2 required
    mod=0 construct a uniform grid respecting the ratio b/a
    mod=1 put default points along a and (b/a)*default along b
    default is the default value of points to take for a when mod=1
    """
    
    a = np.zeros(3) ; a = alats[0, :]
    b = np.zeros(3) ; b = alats[1, :]
    a_mod = math.sqrt(a[0]**2. + a[1]**2. + a[2]**2.)
    b_mod = math.sqrt(b[0]**2. + b[1]**2. + b[2]**2.)
    N_tot = round(density*a_mod*b_mod)
    
    ratio = b_mod/a_mod
    if mod == 0:
        n_a = int(round(math.sqrt(N_tot/ratio)))
        n_b = int(round(ratio*n_a))
    elif mod == 1:
        n_a = default
        n_b = int(round(ratio*default))
    k = 0
    dist_a_x = a[0]/n_a ; dist_a_y = a[1]/n_a ; dist_a_z = a[2]/n_a
    dist_b_x = b[0]/n_b ; dist_b_y = b[1]/n_b ; dist_b_z = b[2]/n_b
    matrix = np.zeros((n_a*n_b, 3))
    for i in range(0, n_a):
        for j in range(0, n_b):
            matrix[k, 0] = i*dist_a_x + j*dist_b_x
            matrix[k, 1] = i*dist_a_y + j*dist_b_y
            matrix[k, 2] = i*dist_a_z + j*dist_b_z
            k += 1
    Plot_GridForPES(matrix, a, b, a_mod, b_mod, n_a, n_b, density, N_tot)

    return matrix


def Plot_GridForPES(matrix, a, b, mod_a, mod_b, n_a, n_b, density, N_tot):
    """
    Plot the uniform grid generated by GenerateGridForPES
    
    """
    
    import matplotlib.pyplot as plt
    from mpl_toolkits.mplot3d import Axes3D
 
    print(matrix)
    print("\na and b vectors: ", a, b)
    print("Total length of a, b: %.2f %.2f"%(mod_a, mod_b))
    print("Density: %.2f pts/A^2.  Required: %2.f points"%(density, N_tot))
    print("Grid generated: ", n_a,"x",n_b,".  Total: %d points\n"%(n_a*n_b))
    
    plt.title("Projection on xy plane")
    plt.plot(matrix[:,0], matrix[:,1], 'o')
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    ax.scatter(matrix[:,0], matrix[:,1], matrix[:,2], c='r', marker='o', label="3D grid")
    x = [0,a[0],a[0]+b[0],b[0],0]
    y = [0,a[1],a[1]+b[1],b[1],0]
    z = [0,a[2],a[2]+b[2],b[2],0]
    ax.plot(x, y, z)
    plt.show()


# =============================================================================
# MEP EVALUATION
# =============================================================================


def GetMEP(alat, xnew, ynew, rbf, theta, n=101, fac=[0.75, 0.75], h=0.001, nstepmax=99999, tol1=1e-7, delta=0.0001):
    """
    Calculation of the MEP with the string method along a provided path
    alat        : array containing alats values [alat_x, alat_y]
    xnew, ynew  : extended x and y points on the potential energy map surface
    rbf         : potential energy surface interpolated with rbf
    theta       : starting splope of the string (with respect to x axis)
    fac         : array used for setting the string length [facx, facy]
    h           : time-step (limited by the ODE step but independent of n1)
    nstepmax    : max possible number of iterations
    tol1        : parameter used as stopping criterion
    delta       : discretized step along x and y for integration
    """
    
    facx=fac[0]
    facy=fac[1]
    alat_x = alat[0]
    alat_y = alat[1]
    
    xa =-facx*alat_x
    ya =-facy*alat_y
    xb = facx*alat_x
    yb = facy*alat_y    
    g = np.linspace(0,1,n)

    if theta == np.pi/2 or theta == 3*np.pi/2: # y direction
        x = np.zeros(n)
        y = (yb-ya)*g+ya
    else: # best starting direction or x direction
        x = (xb-xa)*g+xa
        y = np.tan(theta)*x.copy()
    
    dx = x - np.roll(x,1)
    dy = y - np.roll(y,1)
    dx[0]=0.
    dy[0]=0.
    lxy  = np.cumsum(np.sqrt(dx**2+dy**2))
    lxy /= lxy[n-1]
    xf = interp1d(lxy,x,kind='cubic')
    x  =  xf(g)
    yf = interp1d(lxy,y,kind='cubic')
    y  =  yf(g)
    
    # Main loop
    for nstep in range(int(nstepmax)):
        # calculation of the x and y-components of the force, dVx and dVy respectively
        #derivative of the potential
        x += delta
        tempValp=rbf(x,y)
        x -= 2.*delta
        tempValm=rbf(x,y)
        dVx = 0.5*(tempValp-tempValm)/delta
        x += delta
        y += delta
        tempValp=rbf(x,y)
        y -= 2.*delta
        tempValm=rbf(x,y)
        y += delta
        dVy = 0.5*(tempValp-tempValm)/delta

        x0 = x.copy()
        y0 = y.copy()
        # string steps:
        # 1. evolve
        xt = x- h*dVx
        yt = y - h*dVy
        # 2. derivative
        xt += delta
        tempValp=rbf(xt,yt)
        xt -= 2.*delta
        tempValm=rbf(xt,yt)
        dVxt = 0.5*(tempValp-tempValm)/delta
        xt += delta
        yt += delta
        tempValp=rbf(xt,yt)
        yt -= 2.*delta
        tempValm=rbf(xt,yt)
        yt += delta
        dVyt = 0.5*(tempValp-tempValm)/delta

        x -= 0.5*h*(dVx+dVxt)
        y -= 0.5*h*(dVy+dVyt)
        # 3. reparametrize  
        dx = x-np.roll(x,1)
        dy = y-np.roll(y,1)
        dx[0] = 0.
        dy[0] = 0.
        lxy  = np.cumsum(np.sqrt(dx**2+dy**2))
        lxy /= lxy[n-1]
        xf = interp1d(lxy,x,kind='cubic')
        x  =  xf(g)
        yf = interp1d(lxy,y,kind='cubic')
        y  =  yf(g)
        tol = (np.linalg.norm(x-x0)+np.linalg.norm(y-y0))/n
        if tol <= tol1:
           break
       
    return x, y, nstep, tol



def bsmep(alat, rbf, n=900, fac=[1.5, 1.5], delta_theta=1):   
    facx=fac[0]
    facy=fac[1]
    alat_x = alat[0]
    alat_y = alat[1]   
    xa =-facx*alat_x
    ya =-facy*alat_y
    xb = facx*alat_x
    yb = facy*alat_y    
    
    g = np.linspace(0,1,n)
    x = (xb-xa)*g+xa
    #delta = (xb - xa) / n
    delta = 0.001 
    
    delta_theta *= np.pi/180
    rep = int(np.pi/delta_theta)    
    data_ss = []
    data_th = []   
    theta = 0
    i = 0
    
    ss_x, ss_y = shear_strength_xy(alat, rbf, bsmep=True)
    data_ss.append(float(ss_x))
    data_ss.append(float(ss_y))
    data_th.append(0.)
    data_th.append(np.pi/2.)
    
    while i < rep:
        theta += delta_theta
        if abs(theta*180/np.pi - 90) < 1e-15:
            i += 1 
            pass
        else:
            m = np.tan(theta)
            y = m*x.copy()           
            ss = shear_strength_bsmep(x, y, m, rbf, delta)
            data_th.append(theta)
            data_ss.append(float(ss))
            i +=1
    
    index = data_ss.index(np.amin(np.abs(data_ss)))
    theta = data_th[index]
    ss = data_ss[index]
    
    if theta == np.pi/2. :
        x = np.zeros(n)
        y = (yb-ya)*g+xa
    elif theta == 0. :
        x = (xb-xa)*g+xa
        y = np.zeros(n)
    else:
        x = (xb-xa)*g+xa
        y = np.tan(theta)*x.copy()
    
    print(data_ss)
    # Tiny perturbation of the string
    #x += np.random.rand(len(x))*alat_x/100
    #y += np.random.rand(len(y))*alat_y/100
    
    return x, y, ss, theta


# =============================================================================
# CALCULATE THE SHEAR STRENGTH
# =============================================================================


def shear_strength(x, y, rbf, delta=0.001):
    """
    Calculate the SS given a path and a potential energy surface
    x,y         : points of the string 
    rbf         : interpolated potential energy surface
    delta       : discretized step along x and y for integration
    """  
    n = len(x)
    
    dx = x-np.roll(x,1)
    dy = y-np.roll(y,1)
    dx[0] = 0.
    dy[0] = 0.
    tx = 0.5*(np.roll(x, -1)-np.roll(x, 1))
    ty = 0.5*(np.roll(y, -1)-np.roll(y, 1))    
    # potential computed as integral of projection of gradV on string tangent
    Vz = np.zeros(n)
    #derivative of the potential
    x += delta
    tempValp=rbf(x,y)
    x -= 2.*delta
    tempValm=rbf(x,y)
    dVx = 0.5*(tempValp-tempValm)/delta
    x += delta
    y += delta
    tempValp=rbf(x,y)
    y -= 2.*delta
    tempValm=rbf(x,y)
    y += delta
    dVy = 0.5*(tempValp-tempValm)/delta

    tforce= -(tx*dVx+ty*dVy)
    force= tforce/np.sqrt(tx**2+ty**2)
    
    for i in range(n-1):
        Vz[i+1]=Vz[i] - 0.5*(tforce[i]+tforce[i+1])
        
    Vz -= np.min(Vz)
    Ve = rbf(x,y)
    Ve -= np.min(Ve)
    lxy  = np.cumsum(np.sqrt(dx**2+dy**2))
    data_ss_mep =np.stack((lxy, dVx, dVy, Vz, Ve, force), axis=-1)
    
    SS_min = 10.*np.min(force)
    SS_max = 10.*np.max(force)
    
    return SS_max, SS_min, data_ss_mep         
        

def shear_strength_xy(alat, rbf, npoints=300, bsmep=False):   
    
    delta=0.0001
    alat_x = alat[0]
    alat_y = alat[1]
    
    x=np.arange(-1.5*alat_x, 1.5*alat_x, alat_x/npoints)
    y=np.arange(-1.5*alat_y, 1.5*alat_y, alat_y/npoints)   
    zdev_x=np.zeros(len(x))
    zdev_y=np.zeros(len(y))
    
#    zdev_x, zdev_y = derivative_xy(rbf, x, y, delta)   
    for i in range(len(x)):
        coordx=x[i]
        coordy=y[i]
        zdev_x[i], zdev_y[i] = derivative_xy(rbf, coordx, coordy, delta)
    
    #Shear strength in GPa    
    ss_x = np.amin(zdev_x)*10.0
    ss_y = np.amin(zdev_y)*10.0
    #data=np.stack((zdev_x, zdev_y), axis=-1)

    if bsmep == True:
        ss_x = np.amax(np.abs(zdev_x))*10.0
        ss_y = np.amax(np.abs(zdev_y))*10.0
    
    return abs(ss_x), abs(ss_y)#, data


def derivative_xy(rbf, coordx, coordy, delta):
    coordx=coordx+delta
    tempValp=rbf(coordx,0.)
    coordx=coordx - 2.*delta
    tempValm=rbf(coordx,0.)
    zdev_x=0.5*(tempValp-tempValm)/delta
    
    coordy=coordy+delta
    tempValp=rbf(0.,coordy)
    coordy=coordy - 2.*delta
    tempValm=rbf(0.,coordy)
    zdev_y=0.5*(tempValp-tempValm)/delta
    
    return zdev_x, zdev_y


def shear_strength_bsmep(x, y, m, rbf, delta=0.001): 
    
    zdev=np.zeros(len(x))
#    zdev = derivative_bsmep(rbf, m, x, y, delta)
    
    for i in range(len(x)):
        coordx=x[i]
        coordy=y[i]
        zdev[i]=derivative_bsmep(coordx, coordy, m, rbf, delta)
    
    #Shear strength in GPa
    ss = np.amax(np.abs(zdev))*10.0
    
    return ss



def derivative_bsmep(coordx, coordy, m, rbf, delta):
    coordx=coordx+delta
    coordy=coordy+m*delta
    tempValp=rbf(coordx,coordy)
    
    coordx=coordx - 2.*delta
    coordy=coordy - 2.*delta*m
    tempValm=rbf(coordx,coordy)
    zdev=0.5*(tempValp-tempValm)/delta
    
    return zdev


if __name__ == '__main__':
    print('Testing the creation of a uniform grid for the PES')
    vectors = np.array([[3, 0, 0], [0.8, 4, 0.3]])
    GenerateGridForPES(vectors, 3, to_plot=True)